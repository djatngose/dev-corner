# Delegates
A delegate is an object that knows how to call a method.

A delegate type defines the kind of method that delegate instances can call. Specifically, it defines the method’s return type and its parameter types. The following defines a delegate type called Transformer:

delegate int Transformer (int x);
Transformer is compatible with any method with an int return type and a single int parameter, such as this:

int Square (int x) { return x * x; }
Or, more tersely:

int Square (int x) => x * x;
Assigning a method to a delegate variable creates a delegate instance:

Transformer t = Square;
You can invoke a delegate instance in the same way as a method:

int answer = t(3);    // answer is 9
Here’s a complete example:

Transformer t = Square;          // Create delegate instance
int result = t(3);               // Invoke delegate
Console.WriteLine (result);      // 9

int Square (int x) => x * x;

delegate int Transformer (int x);   // Delegate type declaration
A delegate instance literally acts as a delegate for the caller: the caller invokes the delegate, and then the delegate calls the target method. This indirection decouples the caller from the target method.

The statement

Transformer t = Square;
is shorthand for:

Transformer t = new Transformer (Square);
NOTE
Technically, we are specifying a method group when we refer to Square without brackets or arguments. If the method is overloaded, C# will pick the correct overload based on the signature of the delegate to which it’s being assigned.

The expression

t(3)
is shorthand for:

t.Invoke(3)
NOTE
A delegate is similar to a callback, a general term that captures constructs such as C function pointers.

# what scenarios when use delegate over methods?
Delegates and methods are both used to define and execute code. A delegate is a type that represents a reference to a method with a particular parameter list and return type, while a method is a block of code that performs a specific task.

In general, delegates are used in situations where you need to pass a function as an argument to another function, or where you need to store a reference to a function for later use. Here are some scenarios where using delegates can be useful:

`Event handling:` Delegates are commonly used to handle events in .NET. Event handlers are essentially functions that get called when a particular event occurs, and they are typically defined using a delegate type.
```c#
public class Button
{
    public delegate void ClickHandler(object sender, EventArgs e);
    public event ClickHandler Click;
    
    public void OnClick()
    {
        if (Click != null)
        {
            Click(this, EventArgs.Empty);
        }
    }
}

public class Form
{
    private Button _button;
    
    public Form()
    {
        _button = new Button();
        _button.Click += Button_Click;
    }
    
    private void Button_Click(object sender, EventArgs e)
    {
        Console.WriteLine("Button clicked!");
    }
}
```
`Asynchronous programming:` Delegates can be used to implement asynchronous programming patterns in .NET, such as the asynchronous programming model (APM) and the task-based asynchronous pattern (TAP). These patterns use delegates to represent asynchronous operations that can be started and completed independently of the main program flow.
```c#
ublic class Calculator
{
    public delegate int Calculation(int x, int y);
    
    public static IAsyncResult BeginAdd(int x, int y, AsyncCallback callback, object state)
    {
        Calculation calc = Add;
        return calc.BeginInvoke(x, y, callback, state);
    }
    
    public static int EndAdd(IAsyncResult result)
    {
        Calculation calc = (Calculation)((AsyncResult)result).AsyncDelegate;
        return calc.EndInvoke(result);
    }
    
    private static int Add(int x, int y)
    {
        Thread.Sleep(1000); // simulate long-running operation
        return x + y;
    }
}

public class Program
{
    static void Main(string[] args)
    {
        int x = 5;
        int y = 10;
        
        AsyncCallback callback = ar => Console.WriteLine("Result = {0}", Calculator.EndAdd(ar));
        
        IAsyncResult result = Calculator.BeginAdd(x, y, callback, null);
        
        // do other work while Add method is running asynchronously...
        
        Console.ReadLine(); // wait for user input before exiting
    }
}
```
`LINQ queries: `Delegates are often used in LINQ queries to define the criteria for filtering, sorting, or projecting data. For example, you might use a delegate to specify the criteria for selecting only the elements of a collection that satisfy a particular condition.
```c#
int[] numbers = { 1, 2, 3, 4, 5 };

var evenNumbers = numbers.Where(n => n % 2 == 0);

foreach (var number in evenNumbers)
{
    Console.WriteLine(number);
}
```
 the `evenNumbers` delegate will not actually be executed until the for loop is executed. At that point, the Select method will start to iterate over the numbers collection and call the evenNumbers delegate for each number, returning only the even numbers.

`Functional programming:` Delegates can be used to implement functional programming concepts in .NET, such as higher-order functions and closures. For example, you might use a delegate to define a higher-order function that takes another function as an argument and returns a new function that applies the original function to its input.

```c#
// Higher-order function that takes a function as an argument and returns a new function
public static Func<T, TResult> Compose<T, TMid, TResult>(Func<T, TMid> f, Func<TMid, TResult> g)
{
    return x => g(f(x));
}

// Example usage
Func<int, int> addOne = x => x + 1;
Func<int, int> multiplyByTwo = x => x * 2;

Func<int, int> composed = Compose(addOne, multiplyByTwo);

int result = composed(3); // result is 7
```

# Writing Plug-In Methods with Delegates
A delegate variable is assigned a method at runtime. This is useful for writing plug-in methods. In this example, we have a utility method named Transform that applies a transform to each element in an integer array. The Transform method has a delegate parameter, which you can use for specifying a plug-in transform:
```c#
int[] values = { 1, 2, 3 };
Transform (values, Square);      // Hook in the Square method

foreach (int i in values)
  Console.Write (i + "  ");      // 1   4   9

void Transform (int[] values, Transformer t)
{
  for (int i = 0; i < values.Length; i++)
    values[i] = t (values[i]);
}

int Square (int x) => x * x;
int Cube (int x) => x * x * x;
```
delegate int Transformer (int x);
We can change the transformation just by changing Square to Cube in the second line of code.

Our Transform method is a higher-order function because it’s a function that takes a function as an argument. (A method that returns a delegate would also be a higher-order function.)

# Instance and Static Method Targets
A delegate’s target method can be a local, static, or instance method. The following illustrates a static target method:
```c#
Transformer t = Test.Square;
Console.WriteLine (t(10));      // 100

class Test { public static int Square (int x) => x * x; }

delegate int Transformer (int x);
The following illustrates an instance target method:

Test test = new Test();
Transformer t = test.Square;
Console.WriteLine (t(10));      // 100

class Test { public int Square (int x) => x * x; }

delegate int Transformer (int x);
```
When an instance method is assigned to a delegate object, the latter maintains a reference not only to the method but also to the instance to which the method belongs. The System.Delegate class’s Target property represents this instance (and will be null for a delegate referencing a static method). Here’s an example:
```c#
MyReporter r = new MyReporter();
r.Prefix = "%Complete: ";
ProgressReporter p = r.ReportProgress;
p(99);                                 // %Complete: 99
Console.WriteLine (p.Target == r);     // True
Console.WriteLine (p.Method);          // Void ReportProgress(Int32)
r.Prefix = "";
p(99);                                 // 99

public delegate void ProgressReporter (int percentComplete);

class MyReporter
{
  public string Prefix = "";

  public void ReportProgress (int percentComplete)
    => Console.WriteLine (Prefix + percentComplete);
}
```
Because the instance is stored in the delegate’s Target property, its lifetime is extended to (at least as long as) the delegate’s lifetime.

# Multicast Delegates
All delegate instances have multicast capability. This means that a delegate instance can reference not just a single target method but also a list of target methods. The + and += operators combine delegate instances:

SomeDelegate d = SomeMethod1;
d += SomeMethod2;
The last line is functionally the same as the following:

d = d + SomeMethod2;
Invoking d will now call both SomeMethod1 and SomeMethod2. Delegates are invoked in the order in which they are added.

The - and -= operators remove the right delegate operand from the left delegate operand:

d -= SomeMethod1;
Invoking d will now cause only SomeMethod2 to be invoked.

Calling + or += on a delegate variable with a null value works, and it is equivalent to assigning the variable to a new value:

SomeDelegate d = null;
d += SomeMethod1;       // Equivalent (when d is null) to d = SomeMethod1;
Similarly, calling -= on a delegate variable with a single matching target is equivalent to assigning null to that variable.

NOTE
Delegates are immutable, so when you call += or -=, you’re in fact creating a new delegate instance and assigning it to the existing variable.

If a multicast delegate has a nonvoid return type, the caller receives the return value from the last method to be invoked. The preceding methods are still called, but their return values are discarded. For most scenarios in which multicast delegates are used, they have void return types, so this subtlety does not arise.

NOTE
All delegate types implicitly derive from System.Multicast​De⁠legate, which inherits from System.Delegate. C# compiles +, -, +=, and -= operations made on a delegate to the static Combine and Remove methods of the System.Delegate class.

# Multicast delegate example
Suppose that you wrote a method that took a long time to execute. That method could regularly report progress to its caller by invoking a delegate. In this example, the HardWork method has a ProgressReporter delegate parameter, which it invokes to indicate progress:

public delegate void ProgressReporter (int percentComplete);

public class Util
{
  public static void HardWork (ProgressReporter p)
  {
    for (int i = 0; i < 10; i++)
    {
      p (i * 10);                           // Invoke delegate
      System.Threading.Thread.Sleep (100);  // Simulate hard work
    }
  }
}
To monitor progress, we can create a multicast delegate instance p, such that progress is monitored by two independent methods:
```c#
ProgressReporter p = WriteProgressToConsole;
p += WriteProgressToFile;
Util.HardWork (p);

void WriteProgressToConsole (int percentComplete)
  => Console.WriteLine (percentComplete);

void WriteProgressToFile (int percentComplete)
  => System.IO.File.WriteAllText ("progress.txt",
                                   percentComplete.ToString());
```

# Generic Delegate Types
A delegate type can contain generic type parameters:

public delegate T Transformer<T> (T arg);
With this definition, we can write a generalized Transform utility method that works on any type:

int[] values = { 1, 2, 3 };
Util.Transform (values, Square);      // Hook in Square
foreach (int i in values)
  Console.Write (i + "  ");           // 1   4   9

int Square (int x) => x * x;

public class Util
{
  public static void Transform<T> (T[] values, Transformer<T> t)
  {
    for (int i = 0; i < values.Length; i++)
      values[i] = t (values[i]);
  }
}

# The Func and Action Delegates
With generic delegates, it becomes possible to write a small set of delegate types that are so general they can work for methods of any return type and any (reasonable) number of arguments. These delegates are the Func and Action delegates, defined in the System namespace (the in and out annotations indicate variance, which we cover in the context of delegates shortly):
```c#
delegate TResult Func <out TResult>                ();
delegate TResult Func <in T, out TResult>          (T arg);
delegate TResult Func <in T1, in T2, out TResult>  (T1 arg1, T2 arg2);
... and so on, up to T16

delegate void Action                 ();
delegate void Action <in T>          (T arg);
delegate void Action <in T1, in T2>  (T1 arg1, T2 arg2);
... and so on, up to T16
```
These delegates are extremely general. The Transformer delegate in our previous example can be replaced with a Func delegate that takes a single argument of type T and returns a same-typed value:

public static void Transform<T> (T[] values, Func<T,T> transformer)
{
  for (int i = 0; i < values.Length; i++)
    values[i] = transformer (values[i]);
}
The only practical scenarios not covered by these delegates are ref/out and pointer parameters.

# Delegates Versus Interfaces
A problem that you can solve with a delegate can also be solved with an interface. For instance, we can rewrite our original example with an interface called ITransformer instead of a delegate:
```c#
int[] values = { 1, 2, 3 };
Util.TransformAll (values, new Squarer());
foreach (int i in values)
  Console.WriteLine (i);

public interface ITransformer
{
  int Transform (int x);
}

public class Util
{
 public static void TransformAll (int[] values, ITransformer t)
 {
   for (int i = 0; i < values.Length; i++)
     values[i] = t.Transform (values[i]);
 }
}

class Squarer : ITransformer
{
  public int Transform (int x) => x * x;
}
```
A delegate design might be a better choice than an interface design if one or more of these conditions are true:
  - The interface defines only a single method.
  - Multicast capability is needed.
  - The subscriber needs to implement the interface multiple times.
  - You need to pass a method as an argument to another method or store it in a variable.
  - You want to define a simple, one-off function that is only used in a single context.
  - You are implementing an event system.

Use an interface when:
  - You need to define a contract that specifies a set of methods and properties that a class must implement.
  - You want to provide a common interface for a set of related classes.
  - You want to define a plug-in architecture where different implementations of an interface can be loaded at runtime.
  - You want to define a service that can be consumed by other parts of your application.

# why we need delegate over interface?
Both delegates and interfaces serve different purposes and can be used in different scenarios. However, here are some reasons why you might choose to use a delegate over an interface:

`Simplicity`: Delegates are simpler to define and use than interfaces. Defining an interface requires creating a new type that defines one or more methods. Defining a delegate, on the other hand, is a simpler syntax that can be more readable and less verbose.

`Flexibility`: Delegates can be defined anywhere in your code and can be easily passed around as arguments to methods or stored in variables. Interfaces, on the other hand, are typically defined as separate types and must be implemented by a class or struct.

`Anonymous` functions: Delegates can be defined using anonymous functions, which can be useful for defining small, one-off functions that are only used in a single context.

`Event handling`: Delegates are commonly used for event handling in .NET. They provide a simple and efficient way to register and unregister event handlers, and can be used to implement the observer pattern.

In the ITransformer example, we don’t need to multicast. However, the interface defines only a single method. Furthermore, our subscriber might need to implement ITransformer multiple times, to support different transforms, such as square or cube. With interfaces, we’re forced into writing a separate type per transform because a class can implement ITransformer only once. This is quite cumbersome:

```c#
int[] values = { 1, 2, 3 };
Util.TransformAll (values, new Cuber());
foreach (int i in values)
  Console.WriteLine (i);

class Squarer : ITransformer
{
  public int Transform (int x) => x * x;
}

class Cuber : ITransformer
{
  public int Transform (int x) => x * x * x;
}
```

# Delegate Compatibility
## Type compatibility
Delegate types are all incompatible with one another, even if their signatures are the same:

D1 d1 = Method1;
D2 d2 = d1;                           // Compile-time error

void Method1() { }

delegate void D1();
delegate void D2();
NOTE
The following, however, is permitted:

D2 d2 = new D2 (d1);

Delegate instances are considered equal if they have the same method targets:

D d1 = Method1;
D d2 = Method1;
Console.WriteLine (d1 == d2);         // True

void Method1() { }
delegate void D();
Multicast delegates are considered equal if they reference the same methods in the same order.

## Parameter compatibility
When you call a method, you can supply arguments that have more specific types than the parameters of that method. This is ordinary polymorphic behavior. For the same reason, a delegate can have more specific parameter types than its method target. This is called contravariance. Here’s an example:

StringAction sa = new StringAction (ActOnObject);
sa ("hello");

void ActOnObject (object o) => Console.WriteLine (o);   // hello

delegate void StringAction (string s);
(As with type parameter variance, delegates are variant only for reference conversions.)

A delegate merely calls a method on someone else’s behalf. In this case, the StringAction is invoked with an argument of type string. When the argument is then relayed to the target method, the argument is implicitly upcast to an object.

NOTE
The standard event pattern is designed to help you utilize contravariance through its use of the common EventArgs base class. For example, you can have a single method invoked by two different delegates, one passing a MouseEventArgs and the other passing a KeyEventArgs.

## Return type compatibility
If you call a method, you might get back a type that is more specific than what you asked for. This is ordinary polymorphic behavior. For the same reason, a delegate’s target method might return a more specific type than described by the delegate. This is called covariance:

ObjectRetriever o = new ObjectRetriever (RetriveString);
object result = o();
Console.WriteLine (result);      // hello

string RetriveString() => "hello";

delegate object ObjectRetriever();
ObjectRetriever expects to get back an object, but an object subclass will also do: delegate return types are covariant.

## Generic delegate type parameter variance
In Chapter 3, we saw how generic interfaces support covariant and contravariant type parameters. The same capability exists for delegates, too.

If you’re defining a generic delegate type, it’s good practice to do the following:

Mark a type parameter used only on the return value as covariant (out).

Mark any type parameters used only on parameters as contravariant (in).

Doing so allows conversions to work naturally by respecting inheritance relationships between types.

The following delegate (defined in the System namespace) has a covariant TResult:

delegate TResult Func<out TResult>();
This allows:

Func<string> x = ...;
Func<object> y = x;
The following delegate (defined in the System namespace) has a contravariant T:

delegate void Action<in T> (T arg);
This allows:

Action<object> x = ...;
Action<string> y = x;

# Events
When using delegates, two emergent roles commonly appear: broadcaster and subscriber.

The broadcaster is a type that contains a delegate field. The broadcaster decides when to broadcast, by invoking the delegate.

The subscribers are the method target recipients. A subscriber decides when to start and stop listening by calling += and -= on the broadcaster’s delegate. A subscriber does not know about, or interfere with, other subscribers.

Events are a language feature that formalizes this pattern. An event is a construct that exposes just the subset of delegate features required for the broadcaster/subscriber model. The main purpose of events is to prevent subscribers from interfering with one another.

The easiest way to declare an event is to put the event keyword in front of a delegate member:

// Delegate definition
public delegate void PriceChangedHandler (decimal oldPrice,
                                          decimal newPrice);
public class Broadcaster
{
  // Event declaration
  public event PriceChangedHandler PriceChanged;
}
Code within the Broadcaster type has full access to PriceChanged and can treat it as a delegate. Code outside of Broadcaster can perform only += and -= operations on the PriceChanged event.

HOW DO EVENTS WORK ON THE INSIDE?
Three things happen under the hood when you declare an event as follows:

public class Broadcaster
{
  public event PriceChangedHandler PriceChanged;
}
First, the compiler translates the event declaration into something close to the following:

PriceChangedHandler priceChanged;   // private delegate
public event PriceChangedHandler PriceChanged
{
  add    { priceChanged += value; }
  remove { priceChanged -= value; }
}
The add and remove keywords denote explicit event accessors—which act rather like property accessors. We describe how to write these later.

Second, the compiler looks within the Broadcaster class for references to PriceChanged that perform operations other than += or -= and redirects them to the underlying priceChanged delegate field.

Third, the compiler translates += and -= operations on the event to calls to the event’s add and remove accessors. Interestingly, this makes the behavior of += and -= unique when applied to events: unlike in other scenarios, it’s not simply a shortcut for + and - followed by an assignment.

Consider the following example. The Stock class fires its PriceChanged event every time the Price of the Stock changes:

public delegate void PriceChangedHandler (decimal oldPrice,
                                          decimal newPrice);
public class Stock
{
  string symbol;
  decimal price;

  public Stock (string symbol) => this.symbol = symbol;

  public event PriceChangedHandler PriceChanged;

  public decimal Price
  {
    get => price;
    set
    {
      if (price == value) return;      // Exit if nothing has changed
      decimal oldPrice = price;
      price = value;
      if (PriceChanged != null)           // If invocation list not
        PriceChanged (oldPrice, price);   // empty, fire event.
    }
  }
}
If we remove the event keyword from our example so that PriceChanged becomes an ordinary delegate field, our example would give the same results. However, Stock would be less robust insomuch as subscribers could do the following things to interfere with one another:

Replace other subscribers by reassigning PriceChanged (instead of using the += operator)

Clear all subscribers (by setting PriceChanged to null)

Broadcast to other subscribers by invoking the delegate

# Standard Event Pattern
In almost all cases for which events are defined in the .NET libraries, their definition adheres to a standard pattern designed to provide consistency across library and user code. At the core of the standard event pattern is System.EventArgs, a predefined .NET class with no members (other than the static Empty field). EventArgs is a base class for conveying information for an event. In our Stock example, we would subclass EventArgs to convey the old and new prices when a PriceChanged event is fired:

public class PriceChangedEventArgs : System.EventArgs
{
  public readonly decimal LastPrice;
  public readonly decimal NewPrice;

  public PriceChangedEventArgs (decimal lastPrice, decimal newPrice)
  {
    LastPrice = lastPrice;
    NewPrice = newPrice;
  }
}
For reusability, the EventArgs subclass is named according to the information it contains (rather than the event for which it will be used). It typically exposes data as properties or as read-only fields.

With an EventArgs subclass in place, the next step is to choose or define a delegate for the event. There are three rules:

It must have a void return type.

It must accept two arguments: the first of type object and the second a subclass of EventArgs. The first argument indicates the event broadcaster, and the second argument contains the extra information to convey.

Its name must end with EventHandler.

.NET defines a generic delegate called System.EventHandler<> to help with this:

public delegate void EventHandler<TEventArgs> (object source, TEventArgs e)
NOTE
Before generics existed in the language (prior to C# 2.0), we would have had to instead write a custom delegate as follows:

public delegate void PriceChangedHandler
  (object sender, PriceChangedEventArgs e);
For historical reasons, most events within the .NET libraries use delegates defined in this way.

The next step is to define an event of the chosen delegate type. Here, we use the generic EventHandler delegate:

public class Stock
{
  ...
  public event EventHandler<PriceChangedEventArgs> PriceChanged;
}
Finally, the pattern requires that you write a protected virtual method that fires the event. The name must match the name of the event, prefixed with the word On, and then accept a single EventArgs argument:

public class Stock
{
  ...

  public event EventHandler<PriceChangedEventArgs> PriceChanged;

  protected virtual void OnPriceChanged (PriceChangedEventArgs e)
  {
    if (PriceChanged != null) PriceChanged (this, e);
  }
}
NOTE
To work robustly in multithreaded scenarios (Chapter 14), you need to assign the delegate to a temporary variable before testing and invoking it:

var temp = PriceChanged;
if (temp != null) temp (this, e);
We can achieve the same functionality without the temp variable with the null-conditional operator:

PriceChanged?.Invoke (this, e);
Being both thread-safe and succinct, this is the best general way to invoke events.

This provides a central point from which subclasses can invoke or override the event (assuming the class is not sealed).

Here’s the complete example:

using System;

Stock stock = new Stock ("THPW");
stock.Price = 27.10M;
// Register with the PriceChanged event
stock.PriceChanged += stock_PriceChanged;
stock.Price = 31.59M;

void stock_PriceChanged (object sender, PriceChangedEventArgs e)
{
  if ((e.NewPrice - e.LastPrice) / e.LastPrice > 0.1M)
    Console.WriteLine ("Alert, 10% stock price increase!");
}

public class PriceChangedEventArgs : EventArgs
{
  public readonly decimal LastPrice;
  public readonly decimal NewPrice;

  public PriceChangedEventArgs (decimal lastPrice, decimal newPrice)
  {
    LastPrice = lastPrice; NewPrice = newPrice;
  }
}

public class Stock
{
  string symbol;
  decimal price;

  public Stock (string symbol) => this.symbol = symbol;

  public event EventHandler<PriceChangedEventArgs> PriceChanged;

  protected virtual void OnPriceChanged (PriceChangedEventArgs e)
  {
    PriceChanged?.Invoke (this, e);
  }

  public decimal Price
  {
    get => price;
    set
    {
      if (price == value) return;
      decimal oldPrice = price;
      price = value;
      OnPriceChanged (new PriceChangedEventArgs (oldPrice, price));
    }
  }
}
The predefined nongeneric EventHandler delegate can be used when an event doesn’t carry extra information. In this example, we rewrite Stock such that the PriceChanged event is fired after the price changes, and no information about the event is necessary, other than it happened. We also make use of the EventArgs.Empty property to avoid unnecessarily instantiating an instance of EventArgs:

public class Stock
{
  string symbol;
  decimal price;

  public Stock (string symbol) { this.symbol = symbol; }

  public event EventHandler PriceChanged;

  protected virtual void OnPriceChanged (EventArgs e)
  {
    PriceChanged?.Invoke (this, e);
  }

  public decimal Price
  {
    get { return price; }
    set
    {
      if (price == value) return;
      price = value;
      OnPriceChanged (EventArgs.Empty);
    }
  }
}

# Event Accessors
An event’s accessors are the implementations of its += and -= functions. By default, accessors are implemented implicitly by the compiler. Consider this event declaration:

public event EventHandler PriceChanged;
The compiler converts this to the following:

A private delegate field

A public pair of event accessor functions (add_PriceChanged and remove_PriceChanged) whose implementations forward the += and -= operations to the private delegate field

You can take over this process by defining explicit event accessors. Here’s a manual implementation of the PriceChanged event from our previous example:

private EventHandler priceChanged;         // Declare a private delegate

public event EventHandler PriceChanged
{
  add    { priceChanged += value; }
  remove { priceChanged -= value; }
}
This example is functionally identical to C#’s default accessor implementation (except that C# also ensures thread safety around updating the delegate via a lock-free compare-and-swap algorithm; see http://albahari.com/threading). By defining event accessors ourselves, we instruct C# not to generate default field and accessor logic.

With explicit event accessors, you can apply more complex strategies to the storage and access of the underlying delegate. There are three scenarios for which this is useful:

When the event accessors are merely relays for another class that is broadcasting the event.

When the class exposes many events, for which most of the time very few subscribers exist, such as a Windows control. In such cases, it is better to store the subscriber’s delegate instances in a dictionary because a dictionary will contain less storage overhead than dozens of null delegate field references.

When explicitly implementing an interface that declares an event.

Here is an example that illustrates the last point:

public interface IFoo { event EventHandler Ev; }

class Foo : IFoo
{
  private EventHandler ev;

  event EventHandler IFoo.Ev
  {
    add    { ev += value; }
    remove { ev -= value; }
  }
}
NOTE
The add and remove parts of an event are compiled to add_XXX and remove_XXX methods.

# Event Modifiers
Like methods, events can be virtual, overridden, abstract, or sealed. Events can also be static:

public class Foo
{
  public static event EventHandler<EventArgs> StaticEvent;
  public virtual event EventHandler<EventArgs> VirtualEvent;
}

# Lambda Expressions
A lambda expression is an unnamed method written in place of a delegate instance. The compiler immediately converts the lambda expression to either of the following:

A delegate instance.

An expression tree, of type Expression<TDelegate>, representing the code inside the lambda expression in a traversable object model. This allows the lambda expression to be interpreted later at runtime (see “Building Query Expressions”).

In the following example, x => x * x is a lambda expression:

Transformer sqr = x => x * x;
Console.WriteLine (sqr(3));    // 9

delegate int Transformer (int i);

NOTE:
Internally, the compiler resolves lambda expressions of this type by writing a private method and then moving the expression’s code into that method.

A lambda expression has the following form:

(parameters) => expression-or-statement-block
For convenience, you can omit the parentheses if and only if there is exactly one parameter of an inferable type.

In our example, there is a single parameter, x, and the expression is x * x:

x => x * x;
Each parameter of the lambda expression corresponds to a delegate parameter, and the type of the expression (which may be void) corresponds to the return type of the delegate.

In our example, x corresponds to parameter i, and the expression x * x corresponds to the return type int, therefore being compatible with the Transformer delegate:

delegate int Transformer (int i);
A lambda expression’s code can be a statement block instead of an expression. We can rewrite our example as follows:

x => { return x * x; };
Lambda expressions are used most commonly with the Func and Action delegates, so you will most often see our earlier expression written as follows:

Func<int,int> sqr = x => x * x;
Here’s an example of an expression that accepts two parameters:

Func<string,string,int> totalLength = (s1, s2) => s1.Length + s2.Length;
int total = totalLength ("hello", "world");   // total is 10;
If you do not need to use the parameters, you can discard them with an underscore (from C# 9):

Func<string,string,int> totalLength = (_,_) => ...
Here’s an example of an expression that takes zero arguments:

Func<string> greetor = () => "Hello, world";
From C# 10, the compiler permits implicit typing with lambda expressions that can be resolved via the Func and Action delegates, so we can shorten this statement to:

var greeter = () => "Hello, world";

# Explicitly Specifying Lambda Parameter and Return Types
The compiler can usually infer the type of lambda parameters contextually. When this is not the case, you must specify the type of each parameter explicitly. Consider the following two methods:

void Foo<T> (T x)         {}
void Bar<T> (Action<T> a) {}
The following code will fail to compile, because the compiler cannot infer the type of x:

Bar (x => Foo (x));     // What type is x?
We can fix this by explicitly specifying x’s type as follows:

Bar ((int x) => Foo (x));
This particular example is simple enough that it can be fixed in two other ways:

Bar<int> (x => Foo (x));   // Specify type parameter for Bar
Bar<int> (Foo);            // As above, but with method group
The following example illustrates another use for explicit parameter types (from C# 10):

var sqr = (int x) => x * x;
The compiler infers sqr to be of type Func<int,int>. (Without specifying int, implicit typing would fail: the compiler would know that sqr should be Func<T,T>, but it wouldn’t know what T should be.)

From C# 10, you can also specify the lambda return type:

var sqr = int (int x) => x;
Specifying a return type can improve compiler performance with complex nested lambdas.

# Capturing Outer Variables
A lambda expression can reference any variables that are accessible where the lambda expression is defined. These are called outer variables, and can include local variables, parameters, and fields:

int factor = 2;
Func<int, int> multiplier = n => n * factor;
Console.WriteLine (multiplier (3));            // 6
Outer variables referenced by a lambda expression are called captured variables. A lambda expression that captures variables is called a closure.
NOTE
Variables can also be captured by anonymous methods and local methods. The rules for captured variables, in these cases, are the same.

Captured variables are evaluated when the delegate is actually invoked, not when the variables were captured:

```c#
int factor = 2;
Func<int, int> multiplier = n => n * factor;
factor = 10;
Console.WriteLine (multiplier (3));           // 30
```

Lambda expressions can themselves update captured variables:
```c#
int seed = 0;
Func<int> natural = () => seed++;
Console.WriteLine (natural());           // 0
Console.WriteLine (natural());           // 1
Console.WriteLine (seed);                // 2
```

Captured variables have their lifetimes extended to that of the delegate. In the following example, the local variable seed would ordinarily disappear from scope when Natural finished executing. But because seed has been captured, its lifetime is extended to that of the capturing delegate, natural:

static Func<int> Natural()
{
  int seed = 0;
  return () => seed++;      // Returns a closure
}

static void Main()
{
  Func<int> natural = Natural();
  Console.WriteLine (natural());      // 0
  Console.WriteLine (natural());      // 1
}

A local variable instantiated within a lambda expression is unique per invocation of the delegate instance. If we refactor our previous example to instantiate seed within the lambda expression, we get a different (in this case, undesirable) result:

static Func<int> Natural()
{    
  return() => { int seed = 0; return seed++; };
}

static void Main()
{
  Func<int> natural = Natural();
  Console.WriteLine (natural());           // 0
  Console.WriteLine (natural());           // 0
}

## NOTE
Capturing is internally implemented by “hoisting” the captured variables into fields of a private class. When the method is called, the class is instantiated and lifetime-bound to the delegate instance.

# Static lambdas
When you capture local variables, parameters, instance fields, or the this reference, the compiler may need to create and instantiate a private class to store a reference to the captured data. This incurs a small performance cost, because memory must be allocated (and subsequently collected). In situations where performance is critical, one micro-optimization strategy is to minimize the load on the garbage collector by ensuring that code hot paths incur few or no allocations.

From C# 9, you can ensure that a lambda expression, local function, or anonymous method doesn’t capture state by applying the static keyword. This can be useful in micro-optimization scenarios to prevent unintentional memory allocations. For example, we can apply the static modifier to a lambda expression as follows:
```c#
Func<int, int> multiplier = static n => n * 2;
```
If we later try to modify the lambda expression such that it captures a local variable, the compiler will generate an error:

int factor = 2;
Func<int, int> multiplier = static n => n * factor;  // will not compile

NOTE
The lambda itself evaluates to a delegate instance, which requires a memory allocation. However, if the lambda doesn’t capture variables, the compiler will reuse a single cached instance across the life of the application, so there will be no cost in practice.

This feature can also be used with local methods. In the following example, the Multiply method cannot access the factor variable:

void Foo()
{
  int factor = 123;
  static int Multiply (int x) => x * 2;   // Local static method
}
Of course, the Multiply method could still explicitly allocate memory by calling new. What this protects us from is a potential allocation by stealth. Applying static here is also arguably useful as a documentation tool, indicating a reduced level of coupling.

Static lambdas can still access static variables and constants (because these do not require a closure).

NOTE
The static keyword acts merely as a check; it has no effect on the IL that the compiler produces. Without the static keyword, the compiler does not generate a closure unless it needs to (and even then, it has tricks to mitigate the cost).

## here's an example to demonstrate how using a static lambda can help reduce memory allocation.

Let's say you have a method that needs to perform a filtering operation on a large collection of items:

csharp
Copy code
public List<T> Filter<T>(List<T> items, Func<T, bool> filterFunc)
{
    List<T> result = new List<T>();
    foreach (T item in items)
    {
        if (filterFunc(item))
        {
            result.Add(item);
        }
    }
    return result;
}
In this example, the Filter method takes a list of items and a filtering function as arguments, and returns a new list containing only the items that match the filter condition.

Now, let's say you have a scenario where you need to filter a list of numbers based on whether they are even or odd. You could define a lambda function like this:

sql
Copy code
List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
List<int> evenNumbers = Filter(numbers, x => x % 2 == 0);
In this case, the lambda function x => x % 2 == 0 checks whether a given number is even by checking if its remainder when divided by 2 is 0.

If you use a non-static lambda function here, a new instance of the function object will be created each time the lambda is called. This can result in increased memory allocation, especially if you are filtering a large collection of items.

To avoid this, you can define the lambda function as static, like this:

c
Copy code
static Func<int, bool> isEven = x => x % 2 == 0;

List<int> evenNumbers = Filter(numbers, isEven);
By defining the lambda function as static, it is created only once and stored in memory for the lifetime of the application. This can help reduce memory allocation and potentially improve performance, especially if you are filtering a large collection of items

# Capturing iteration variables
When you capture the iteration variable of a for loop, C# treats that variable as though it were declared outside the loop. This means that the same variable is captured in each iteration. The following program writes 333 instead of 012:

Action[] actions = new Action[3];

for (int i = 0; i < 3; i++)
  actions [i] = () => Console.Write (i);

foreach (Action a in actions) a();     // 333
Each closure (shown in boldface) captures the same variable, i. (This actually makes sense when you consider that i is a variable whose value persists between loop iterations; you can even explicitly change i within the loop body if you want.) The consequence is that when the delegates are later invoked, each delegate sees i’s value at the time of invocation—which is 3. We can illustrate this better by expanding the for loop, as follows:

Action[] actions = new Action[3];
int i = 0;
actions[0] = () => Console.Write (i);
i = 1;
actions[1] = () => Console.Write (i);
i = 2;
actions[2] = () => Console.Write (i);
i = 3;
foreach (Action a in actions) a();    // 333
The solution, if we want to write 012, is to assign the iteration variable to a local variable that’s scoped within the loop:

Action[] actions = new Action[3];
for (int i = 0; i < 3; i++)
{
  int loopScopedi = i;
  actions [i] = () => Console.Write (loopScopedi);
}
foreach (Action a in actions) a();     // 012
Because loopScopedi is freshly created on every iteration, each closure captures a different variable.

NOTE
Prior to C# 5.0, foreach loops worked in the same way. This caused considerable confusion: unlike with a for loop, the iteration variable in a foreach loop is immutable, and so you would expect it to be treated as local to the loop body. The good news is that it’s now fixed, and you can safely capture a foreach loop’s iteration variable without surprises.

# Lambda Expressions Versus Local Methods
The functionality of local methods (see “Local methods”) overlaps with that of lambda expressions. Local methods have the following three advantages:
  - They can be recursive (they can call themselves) without ugly hacks.
  - They avoid the clutter of specifying a delegate type.
  - They incur slightly less overhead.
  - Local methods, on the other hand, are useful when you need to reuse a function in multiple places within a single method. They can also be more readable than long, complex lambda expressions. Here's an example:
  - Refactoring: Local methods can be used to extract a piece of code from a larger method and reuse it elsewhere in the same class, making the code more modular and easier to maintain.
  - Encapsulation: Local methods can be used to encapsulate a block of code that should not be accessed from outside the method in which it is defined, reducing the risk of unintended side effects or code duplication.
```c#
public static int Sum(int[] numbers)
{
    return GetSum();

    int GetSum()
    {
        int sum = 0;

        foreach (int number in numbers)
        {
            sum += number;
        }

        return sum;
    }
}
```
Local methods are more efficient because they avoid the indirection of a delegate (which costs some CPU cycles and a memory allocation). They can also access local variables of the containing method without the compiler having to “hoist” the captured variables into a hidden class.

Lambda expressions are often used when you need to pass a small, one-time use function to another method. They are particularly useful when working with LINQ queries, where you might want to filter, sort or transform data based on a particular condition
However, in many cases you need a delegate—most commonly when calling a higher-order function, that is, a method with a delegate-typed parameter:
```c#
public void Foo (Func<int,bool> predicate) { ... }
```

# Anonymous Methods
Anonymous methods are a C# 2.0 feature that was mostly subsumed by C# 3.0’s lambda expressions. An anonymous method is like a lambda expression, but it lacks the following features:

Implicitly typed parameters

Expression syntax (an anonymous method must always be a statement block)

The ability to compile to an expression tree, by assigning to Expression<T>

An anonymous method uses the delegate keyword followed (optionally) by a parameter declaration and then a method body. For example:

Transformer sqr = delegate (int x) {return x * x;};
Console.WriteLine (sqr(3));                            // 9

delegate int Transformer (int i);
The first line is semantically equivalent to the following lambda expression:

Transformer sqr =       (int x) => {return x * x;};
Or simply:

Transformer sqr =            x  => x * x;
Anonymous methods capture outer variables in the same way lambda expressions do, and can be preceded by the static keyword to make them behave like static lambdas.

## NOTE
A unique feature of anonymous methods is that you can omit the parameter declaration entirely—even if the delegate expects it. This can be useful in declaring events with a default empty handler:

public event EventHandler Clicked = delegate { };
This avoids the need for a null check before firing the event. The following is also legal:

// Notice that we omit the parameters:
Clicked += delegate { Console.WriteLine ("clicked"); };