

# Symmetric Encryption
Symmetric encryption uses the same key for encryption as for decryption. The .NET BCL provides four symmetric algorithms, of which Rijndael (pronounced “Rhine Dahl” or “Rain Doll”) is the premium; the other algorithms are intended mainly for compatibility with older applications. Rijndael is both fast and secure and has two implementations:
• `TheRijndaelclass` 
• `TheAesclass`

The two are almost identical, except that Aes does not let you weaken the cipher by changing the block size. Aes is recommended by the CLR’s security team.
Rijndael and Aes allow symmetric keys of length 16, 24, or 32 bytes: all are cur‐ rently considered secure. Here’s how to encrypt a series of bytes as they’re written to a file, using a 16-byte key:
```c#
    byte[] key = {145,12,32,245,98,132,98,214,6,77,131,44,221,3,9,50};
    byte[] iv  = {15,122,132,5,93,198,44,31,9,39,241,49,250,188,80,7};
    byte[] data = { 1, 2, 3, 4, 5 };   // This is what we're encrypting.
    using (SymmetricAlgorithm algorithm = Aes.Create())
    using (ICryptoTransform encryptor = algorithm.CreateEncryptor (key, iv))
    using (Stream f = File.Create ("encrypted.bin"))
    using (Stream c = new CryptoStream (f, encryptor, CryptoStreamMode.Write))
c.Write (data, 0, data.Length);
```
The following code decrypts the file:
```c#
    byte[] key = {145,12,32,245,98,132,98,214,6,77,131,44,221,3,9,50};
    byte[] iv  = {15,122,132,5,93,198,44,31,9,39,241,49,250,188,80,7};
    byte[] decrypted = new byte[5];
    using (SymmetricAlgorithm algorithm = Aes.Create())
    using (ICryptoTransform decryptor = algorithm.CreateDecryptor (key, iv))
    using (Stream f = File.OpenRead ("encrypted.bin"))
    using (Stream c = new CryptoStream (f, decryptor, CryptoStreamMode.Read))
      for (int b; (b = c.ReadByte()) > -1;)
        Console.Write (b + " ");                            // 1 2 3 4 5
```
In this example, we made up a key of 16 randomly chosen bytes. If the wrong key was used in decryption, CryptoStream would throw a CryptographicException. Catching this exception is the only way to test whether a key is correct.

The cryptography work is divided among the classes. Aes is the mathematician; it applies the cipher algorithm, along with its encryptor and decryptor transforms. CryptoStream is the plumber; it takes care of stream plumbing. You can replace Aes with a different symmetric algorithm yet still use CryptoStream.
CryptoStream is bidirectional, meaning you can read or write to the stream depend‐ ing on whether you choose CryptoStreamMode.Read or CryptoStreamMode.Write. Both encryptors and decryptors are read and write savvy, yielding four combina‐ tions—the choice can have you staring at a blank screen for a while! It can be helpful to model reading as “pulling” and writing as “pushing.” If in doubt, start with Write for encryption and Read for decryption; this is often the most natural.
To generate a random key or IV, use RandomNumberGenerator in System.Cryptog raphy. The numbers it produces are genuinely unpredictable, or cryptographically strong (the System.Random class does not offer the same guarantee). Here’s an example:
    byte[] key = new byte [16];
    byte[] iv  = new byte [16];
    RandomNumberGenerator rand = RandomNumberGenerator.Create();
    rand.GetBytes (key);
    rand.GetBytes (iv);
Or, from .NET 6:
    byte[] key = RandomNumberGenerator.GetBytes (16);
    byte[] iv = RandomNumberGenerator.GetBytes (16);
If you don’t specify a key and IV, cryptographically strong random values are generated automatically. You can query these through the Aes object’s Key and IV properties.



# Encrypting in Memory

```c#
From .NET 6, you can utilize the EncryptCbc and DecryptCbc methods to shortcut the process of encrypting and decrypting byte arrays:
    public static byte[] Encrypt (byte[] data, byte[] key, byte[] iv)
    {
      using Aes algorithm = Aes.Create();
          algorithm.Key = key;
      return algorithm.EncryptCbc (data, iv);
    }
    public static byte[] Decrypt (byte[] data, byte[] key, byte[] iv)
    {
      using Aes algorithm = Aes.Create();
      algorithm.Key = key;
      return algorithm.DecryptCbc (data, iv);
}


```

Here’s an equivalent that works in all.NET versions:
    public static byte[] Encrypt (byte[] data, byte[] key, byte[] iv)
    {
      using (Aes algorithm = Aes.Create())
      using (ICryptoTransform encryptor = algorithm.CreateEncryptor (key, iv))
        return Crypt (data, encryptor);
    }
    public static byte[] Decrypt (byte[] data, byte[] key, byte[] iv)
    {
      using (Aes algorithm = Aes.Create())
      using (ICryptoTransform decryptor = algorithm.CreateDecryptor (key, iv))
        return Crypt (data, decryptor);
    }
    static byte[] Crypt (byte[] data, ICryptoTransform cryptor)
    {
      MemoryStream m = new MemoryStream();
      using (Stream c = new CryptoStream (m, cryptor, CryptoStreamMode.Write))
        c.Write (data, 0, data.Length);
      return m.ToArray();
}
Here, CryptoStreamMode.Write works best for both encryption and decryption,
since in both cases we’re “pushing” into a fresh memory stream. Here are overloads that accept and return strings:
    public static string Encrypt (string data, byte[] key, byte[] iv)
    {
return Convert.ToBase64String (
Encrypt (Encoding.UTF8.GetBytes (data), key, iv));
}
    public static string Decrypt (string data, byte[] key, byte[] iv)
    {
return Encoding.UTF8.GetString (
Decrypt (Convert.FromBase64String (data), key, iv));
}
The following demonstrates their use:
    byte[] key = new byte[16];
    byte[] iv = new byte[16];
     var cryptoRng = RandomNumberGenerator.Create();
    cryptoRng.GetBytes (key);
    cryptoRng.GetBytes (iv);
string encrypted = Encrypt ("Yeah!", key, iv);
Console.WriteLine (encrypted); // R1/5gYvcxyR2vzPjnT7yaQ==
    string decrypted = Decrypt (encrypted, key, iv);
    Console.WriteLine (decrypted);                 // Yeah!

# Key Management
Key management is a critical element of security: if your keys are exposed, so is your data. You need to consider who should have access to keys and how to back them up in case of hardware failure while storing them in a manner that prevents unauthorized access.
It is inadvisable to hardcode encryption keys because popular tools exist to decom‐ pile assemblies with little expertise required. A better option (on Windows) is to manufacture a random key for each installation, storing it securely with Windows Data Protection.
For applications deployed to the cloud, Microsoft Azure and Amazon Web Services (AWS) offer key-management systems with additional features that can be useful in an enterprise environment, such as audit trails.
If you’re encrypting a message stream, public-key encryption still provides the best option.